<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- ===== SEO ===== -->
    <title>Lock-Free SPSC Ring Buffer in C++ | Atomics, Memory Ordering, Low Latency Systems</title>

    <meta name="description"
        content="Deep dive into Lock-Free Single Producer Single Consumer ring buffer using C++ atomics. Learn acquire-release memory ordering, ultra low latency design, and HFT level concurrency optimization." />

    <meta name="keywords"
        content="Lock Free Ring Buffer, SPSC Queue, C++ atomics, memory ordering, acquire release, lock free concurrency, high frequency trading systems, low latency C++" />

    <meta name="author" content="Shivam Kachhadiya" />

    <link rel="stylesheet" href="../css/blog.css" />
</head>

<body>

    <!-- ================= NAVBAR ================= -->
    <header class="navbar">
        <h2><a href="/">ShivamSys</a></h2>
        <nav>
            <a href="/blog/">â† Back to Blog</a>
        </nav>
    </header>

    <!-- ================= ARTICLE ================= -->
    <article class="post-container">

        <h1 class="post-title">
            Lock-Free SPSC Ring Buffer in C++
        </h1>

        <p class="post-meta">
            Written by <strong>Shivam Kachhadiya</strong> â€¢
            <time datetime="2026-02-16">Last Updated: Feb 16, 2026</time>
        </p>

        <!-- ================= INTRO ================= -->
        <p class="lead">
            Designing <b>ultra-low latency systems</b> means eliminating locks, syscalls, and unpredictable pauses.
            In high-frequency trading or real-time engines, even <b>microseconds matter</b>.
            This article explains how to build a <b>Lock-Free Single Producer Single Consumer (SPSC) Ring Buffer</b>
            using <b>C++ atomics and memory ordering</b>.
        </p>

        <!-- ================= PROBLEM ================= -->
        <h2>ğŸš€ Problem Statement</h2>

        <p>
            We need fast communication between two threads without mutex overhead.
            Mutex causes:
        </p>

        <ul>
            <li>context switching</li>
            <li>kernel involvement</li>
            <li>latency spikes</li>
        </ul>

        <p>
            Solution â†’ <b>Lock-free ring buffer</b>
        </p>

        <!-- ================= ARCHITECTURE ================= -->
        <h2>ğŸ§  Architecture</h2>

        <pre class="diagram">
Producer  --->  [ Ring Buffer ]  --->  Consumer
</pre>

        <p>
            Only:
        </p>

        <ul>
            <li>Producer writes <b>tail</b></li>
            <li>Consumer writes <b>head</b></li>
        </ul>

        <p class="highlight">
            This is called the <b>Single Writer Principle</b> â†’ zero write contention â†’ naturally lock-free.
        </p>

        <!-- ================= DATA STRUCTURE ================= -->
        <h2>ğŸ“¦ Data Structure</h2>

        <pre><code class="code">
template&lt;typename T, size_t N&gt;
struct RingBuffer {
    T buffer[N];

    std::atomic&lt;size_t&gt; head;
    std::atomic&lt;size_t&gt; tail;
};
</code></pre>

        <p>
            Explain each:
        </p>

        <ul>
            <li><b>buffer</b> â†’ Stores elements</li>
            <li><b>head</b> â†’ Index to read</li>
            <li><b>tail</b> â†’ Index to write</li>
        </ul>

        <!-- ================= PRODUCER ================= -->
        <h2>âš™ï¸ Producer (push)</h2>

        <p>
            Producer steps:
        </p>

        <ul>
            <li>Load head (acquire)</li>
            <li>Check if buffer full</li>
            <li>Write element</li>
            <li>Update tail (release)</li>
        </ul>

        <p>
            Why? Before updating tail â†’ data must be fully written. Release ensures consumer sees correct memory.
        </p>

        <pre><code class="code">
bool push(const T& item) {
    size_t t = tail.load(std::memory_order_relaxed);
    size_t next = (t + 1) % N;

    if (next == head.load(std::memory_order_acquire))
        return false; // full

    buffer[t] = item;

    tail.store(next, std::memory_order_release);
    return true;
}
</code></pre>

        <!-- ================= CONSUMER ================= -->
        <h2>âš™ï¸ Consumer (pop)</h2>

        <p>
            Consumer steps:
        </p>

        <ul>
            <li>Load tail (acquire)</li>
            <li>If empty â†’ return</li>
            <li>Read data</li>
            <li>Update head (release)</li>
        </ul>

        <pre><code class="code">
bool pop(T& item) {
    size_t h = head.load(std::memory_order_relaxed);

    if (h == tail.load(std::memory_order_acquire))
        return false; // empty

    item = buffer[h];

    head.store((h + 1) % N, std::memory_order_release);
    return true;
}
</code></pre>

        <!-- ================= MEMORY ORDERING ================= -->
        <h2>ğŸ§© Why Acquireâ€“Release?</h2>

        <p>
            <b>Release</b> â†’ Ensures all writes before store become visible<br>
            <b>Acquire</b> â†’ Ensures all reads after load see latest data
        </p>

        <p class="highlight">
            Creates <b>happens-before</b> relationship between producer and consumer.
        </p>

        <!-- ================= PERFORMANCE ================= -->
        <h2>ğŸ”¥ Why No Mutex?</h2>

        <p>
            Mutex â†’ kernel involvement, context switch, 1000ns+, unpredictable<br>
            Atomics â†’ CPU instruction only, few nanoseconds<br>
            Lock-free gives deterministic latency, high throughput â†’ ideal for HFT
        </p>

        <h2>ğŸ”¥ Why Fast?</h2>

        <ul>
            <li>No locks â†’ no syscalls</li>
            <li>Contiguous memory â†’ cache friendly</li>
            <li>No heap â†’ preallocated</li>
            <li>No false sharing â†’ alignas(64)</li>
        </ul>

        <!-- ================= COMMON FOLLOW-UPS ================= -->
        <h2>ğŸ§  Common Follow-ups</h2>

        <ul>
            <li>Q: Why only SPSC? <br> A: MPMC needs CAS â†’ slower + ABA issues</li>
            <li>Q: Why modulo slow? <br> A: Use power-of-two + bitmask â†’ index & (N-1)</li>
            <li>Q: What if producer faster? <br> A: Buffer full â†’ drop or spin</li>
            <li>Q: What about false sharing? <br> A: Pad head and tail</li>
        </ul>

        <!-- ================= PERFECT INTERVIEW ANSWER ================= -->
        <h2>ğŸ“ Perfect Interview Answer</h2>

        <p>
            I implemented a lock-free SPSC ring buffer to achieve ultra-low latency inter-thread communication.
            Since only one thread writes head and one writes tail, thereâ€™s no write contention.
            I used std::atomic with acquire-release ordering to guarantee visibility without locks.
            The buffer is preallocated and cache-aligned to avoid heap allocation and false sharing.
            This eliminates syscalls and context switching, allowing us to achieve 10â€“20M messages/sec with
            sub-microsecond latency.
        </p>

        <!-- ================= SCENARIO EXAMPLE ================= -->
        <h2>ğŸ”¥ Problem Setup (Example)</h2>

        <p>Assume:</p>
        <ul>
            <li>Buffer size = 4</li>
            <li>Indexes: 0 1 2 3</li>
        </ul>

        <p>Initial state:</p>
        <pre class="diagram">
buffer: [ _  _  _  _ ]
head = 0
tail = 0
</pre>

        <p>Meaning: head == tail â†’ EMPTY</p>

        <h3>ğŸ¯ Scenario Simulation</h3>

        <ol>
            <li>Producer pushes A â†’ tail moves to 1 â†’ buffer: [ A _ _ _ ]</li>
            <li>Producer pushes B â†’ tail = 2 â†’ buffer: [ A B _ _ ]</li>
            <li>Producer pushes C â†’ tail = 3 â†’ buffer: [ A B C _ ]</li>
            <li>Consumer pops first item â†’ head = 1 â†’ reads A â†’ buffer stays [ A B C _ ]</li>
            <li>Consumer pops second item â†’ head = 2 â†’ reads B â†’ buffer: [ A B C _ ]</li>
            <li>Producer pushes D â†’ tail wraps to 0 â†’ buffer: [ A B C D ]</li>
            <li>Producer pushes E â†’ tail = 1 â†’ buffer: [ E B C D ]</li>
            <li>Consumer pops all â†’ head = 1 â†’ reads C,D,E â†’ final state head=tail=1 â†’ EMPTY</li>
        </ol>

        <p class="highlight">
            Works without locks because producer only modifies tail and consumer only modifies head. Only reads other's
            pointer â†’ safe.
        </p>

        <!-- ================= TAGS ================= -->
        <div class="tags">
            <span class="tag">Lock-Free</span>
            <span class="tag">C++</span>
            <span class="tag">Atomics</span>
            <span class="tag">Concurrency</span>
            <span class="tag">Low Latency</span>
        </div>

    </article>

    <footer>
        Â© 2026 ShivamSys â€¢ Systems + DSA Engineering Blog
    </footer>

    <script src="../js/main.js" defer></script>
    <div class="cursor-dot"></div>
    <div class="cursor-ring"></div>
    <script src="../js/cursor.js" defer></script>

</body>

</html>