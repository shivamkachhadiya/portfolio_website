<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- SEO -->
    <title>Minimum Path Sum LeetCode 64 ‚Äì C++ Memoization DP Solution | ShivamSys</title>
    <meta name="description"
        content="LeetCode 64 Minimum Path Sum explained with intuition, memoization dynamic programming, handwritten notes and optimized C++ solution." />

    <link rel="stylesheet" href="../css/blog.css" />
</head>

<body>

    <header class="navbar">
        <h2><a href="/">ShivamSys</a></h2>
        <nav>
            <!-- Works locally + hosting -->
            <a href="/blog/">‚Üê Back to Blog</a>
        </nav>
    </header>


    <article class="post-container">

        <h1>LeetCode 64 ‚Äî Minimum Path Sum (C++ DP + Memoization)</h1>

        <p>
            This problem is a classic <b>Dynamic Programming grid problem</b>.
            We must travel from top-left ‚Üí bottom-right while minimizing total cost.
        </p>


        <!-- ================= PROBLEM ================= -->
        <h2>üß© Problem Statement</h2>

        <p>
            Given an <b>m √ó n grid</b> filled with non-negative numbers, find a path which minimizes
            the sum of all numbers along its path.
        </p>

        <p><b>Allowed moves:</b> Right or Down only</p>


        <!-- ================= EXAMPLES ================= -->
        <h2>üìå Examples</h2>

        <pre><code>
Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7

Input: grid = [[1,2,3],[4,5,6]]
Output: 12
</code></pre>


        <!-- ================= NOTES ================= -->
        <h2>üìù Handwritten Notes</h2>

        <img src="../images/notes/min-path-sum.jpg" alt="Minimum Path Sum handwritten notes by Shivam" loading="lazy">


        <!-- ================= INTUITION ================= -->
        <h2>üí° Intuition</h2>

        <ul>
            <li>From every cell, you can come from <b>top</b> or <b>left</b></li>
            <li>Choose the minimum cost of both</li>
            <li>Use memoization to avoid recomputation</li>
        </ul>

        <p>
            State:
        </p>

        <pre><code>
dp[i][j] = grid[i][j] + min(top, left)
</code></pre>


        <!-- ================= APPROACH ================= -->
        <h2>‚öôÔ∏è Approach (Memoization)</h2>

        <ol>
            <li>Use recursion from bottom-right ‚Üí top-left</li>
            <li>Base case at (0,0)</li>
            <li>Store results in dp[][]</li>
            <li>Time Complexity: O(m √ó n)</li>
            <li>Space Complexity: O(m √ó n)</li>
        </ol>


        <!-- ================= CODE ================= -->
        <h2>üíª C++ Code</h2>

        <pre><code>
class Solution {
public:
    int solve(vector<vector<int>>& grid, int i, int j,
              vector<vector<int>>& dp) {

        if (i < 0 || j < 0)
            return 1e9;

        if (i == 0 && j == 0)
            return grid[0][0];

        if (dp[i][j] != -1)
            return dp[i][j];

        int top  = grid[i][j] + solve(grid, i-1, j, dp);
        int left = grid[i][j] + solve(grid, i, j-1, dp);

        return dp[i][j] = min(top, left);
    }

    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        vector<vector<int>> dp(m, vector<int>(n, -1));

        return solve(grid, m-1, n-1, dp);
    }
};
</code></pre>


        <!-- ================= COMPLEXITY ================= -->
        <h2>üìä Complexity</h2>

        <ul>
            <li>Time ‚Üí O(m √ó n)</li>
            <li>Space ‚Üí O(m √ó n)</li>
        </ul>


        <!-- ================= TAGS ================= -->
        <p style="margin-top:40px;">
            <span class="tag">DP</span>
            <span class="tag">Memoization</span>
            <span class="tag">C++</span>
            <span class="tag">LeetCode</span>
        </p>

    </article>


    <footer>
        ¬© 2026 Shivam Kachhadiya ‚Ä¢ ShivamSys.in
    </footer>

</body>

</html>